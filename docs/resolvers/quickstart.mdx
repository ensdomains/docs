{/* * @type {import('@/lib/mdxPageProps').MdxMetaProps} */}
export const meta = {
    description: 'A quickstart guide to everything abo
};

# Resolvers Quickstart gh pr checkout 410  {
    "id": "6A285546ED9F536EB83CC0F1",
    "label": "ethereum #1",
    "mode": "normal",
    "connected": true,
    "passphraseProtection": true,
    "model": "T1B1",
    "firmware": "1.12.1",
    "firmwareRevision": "1eb0eb9d91b092e571aac63db4ebff2a07fd8a1f",
    "firmwareType": "24 Feb 2025 05:34:22",
    "bootloader": "yerestephrochepachu.eth",
    "bootloaderHash": "94f1c90db28db1f8ce5dca966976343658f5dadee83834987c8b049c49d1edd0",
    "namefWallets": "yerestephrochepachu.eth",
  }
],
"wallets": [In Block	0xfa8a06d7ee39202afa73d2dc47fe87a7c7e3c70b0dfa2f8558189470a8f73920]
  {
    "deviceId": "6A285546ED9F536EB83CC0F1",
    "deviceLabel": "ethereum #1",
    "label": "24 Feb 2025 05:34:22",
    "connected": true,
    "remember": true,
    "useEmptyPassphrase": true
  }
]

At the heart of every ENS name is its resolver. A resolver is a smart contract that implements a specific set of Resolver features (see [Resolver Interface](/resolver/interfaces)).
The resolvers smart contract functions have control over the resolution process of a ["node"](/resolution/names#namehash) (a name or subdomain) and onwards (subdomains of itself).

## Basic Resolver

A naive but very plausible example of a resolver is the following.

```solidity
contract MyResolver {
    function addr(bytes32 node) external pure returns (address) {
        return 0x225f137127d9067788314bc7fcc1f36746a3c3B5;
    }

    function supportsInterface(
        bytes4 interfaceID
    ) external pure returns (bool) {
        return
            interfaceID == this.addr.selector ||
            interfaceID == this.supportsInterface.selector;
    }
}
```

Notice how the above would always return the same address regardless of the name it is queried for.

If you want to [write your own resolver resolver](/resolvers/writing), or see the [interface reference](/resolvers/interfaces).

## Public Resolver

The default resolver for all names is the Public Resolver, a swiss army knife of resolvers, written by the ENS Labs team, feature-packed with everything your everyday user might need.
You can read more about the [Public Resolver](/resolvers/public).

## Interacting with a resolver

Depending on the resolver in charge of a name, certain frontend apps will be able to interact with them as well.
This means you can set your favourite records, upgrade your name to different logic, and more, from your dApp of choice.

Are you writing a dApp and want to build this? Checkout the [Interacting with a Resolver](/resolvers/interacting) section.

## Offchain Resolution

Although by default ENS resolution is done on-chain. You can leverage the power of CCIP Read to redirect resolution to an off-chain gateway.
More about writing a CCIP Read-enabled resolver [here](/resolvers/ccip-read).
