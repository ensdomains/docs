import { Card } from '../../../components/ui/Card'

# Resolución

El proceso por el cual cargamos información sobre un nombre se llama resolución. Es un proceso simple, pero es importante entenderlo.
Aquí hay un diagrama de algunos de los contratos involucrados cuando se resuelve un nombre.

<Card>
  <img
    src="/img/resolution-diagram-1.png"
    alt="Diagrama del proceso de resolución ENS"
  />
</Card>

El proceso de resolución involucra múltiples partes. Más notablemente el [Registro](/registry/ens), múltiples Registradores ([Registrador ETH](/es/registry/eth), [Registrador DNS](/es/registry/dns), [Registrador Inverso](/registry/reverse), etc)
y el concepto de un [Resolver](/es/resolvers/quickstart).

## Cómo resolver

Aquí hay una pequeña mirada a lo que sucede bajo el capó de tu librería favorita cuando haces una búsqueda de nombre.

### 1. Encontrar el Resolver

Cada nombre tiene un "resolver". Un resolver es simplemente un contrato que implementa la [especificación del resolver](/es/resolvers/quickstart) y puede ser consultado para información sobre un nombre.
Para obtener el resolver responsable de un nombre, puedes consultar [El Registro](/registry/ens) para el `resolver` de un nombre.

:::code-group

```solidity [Solidity]
ENS.resolver(bytes32 node) view returns (address)
```

```tsx [Wagmi]
// https://wagmi.sh/react/api/hooks/useEnsResolver
import { normalize } from 'viem/ens'
import { useEnsResolver } from 'wagmi'

export const MyResolver = () => {
  const { data: myResolver } = useEnsResolver({
    name: normalize('luc.eth'), // El nombre a buscar
  })

  return <div>{myResolver}</div>
}
```

```ts [Ethers]
const resolver = await provider.getResolver('luc.eth')
```

```ts [viem]
// https://viem.sh/docs/ens/actions/getEnsResolver.html
import { normalize } from 'viem/ens'

import { publicClient } from './client'

const ensResolver = await publicClient.getEnsResolver({
  name: normalize('luc.eth'),
})
```

```py [Web3.py]
# https://web3py.readthedocs.io/en/latest/ens_overview.html#working-with-resolvers
from ens.auto import ns

resolver = ns.resolver('alice.eth')
```

:::

Para verificar qué especificaciones son implementadas por un resolver, puedes llamar a `supportsInterface(bytes4 interfaceID)` en el resolver con el interfaceID que te gustaría probar.

### 2. Consultar el Resolver

Ahora que has encontrado el resolver responsable del nombre en cuestión, puedes consultarlo para la información que te interesa.
Hay muchas formas en las que puedes consultar el resolver, `addr()` `text()` `contenthash()` `abi()` etc.

Si el resolver soporta registros de texto, puedes llamar a `text()` para obtener ese registro de texto para el nombre.
Más sobre cargar información de un resolver se puede encontrar [aquí](/resolvers/interacting).

#### Resolución Wildcard

Además, todas las funciones anteriores pueden ser enviadas a la función `resolve()`, especificada en [ENSIP-10](/ensip/10).
Esto permite no solo funcionalidad multicall, sino también implementación más fácil de EIP-3668, y más.
La mayoría de clientes y muchos resolvers utilizan resolución wildcard como su forma principal de resolución.

## Resolución Inversa

Debido a la naturaleza modular de cómo ENS está diseñado, también es posible buscar el "nombre primario" de una dirección.
Este proceso en realidad usa resolución hacia adelante bajo el capó, leíste bien - es solo resolución hacia adelante.

Para buscar el nombre primario de una dirección dada, debes hacer una búsqueda de resolver para `addr.reverse` y luego consultar el campo `name()` en el resolver.
Este campo name devuelve el nombre "preferido" para la dirección. Siempre debes seguir una búsqueda inversa con una búsqueda hacia adelante para verificar que el nombre resultante apunte de vuelta a la dirección original. Si la dirección no coincide, muestra la dirección en lugar del nombre invertido.

```solidity
/// @dev El punto de partida para toda resolución ENS es el Registro
ENS ens = 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e;

/// @dev El hash del nodo para "addr.reverse"
bytes32 ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;

/// @dev Devuelve el hash del nodo para los registros inversos de una cuenta dada, `{address}.addr.reverse`
function reverseNode(address addr) public pure returns (bytes32) {
  return keccak256(
      abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))
    );
}

/// @dev Obtener el registro inverso para una dirección
function getReverseRecord(address addr) public view returns (string) {
    bytes32 reverseNodeHash = reverseNode(addr);

    // Obtener el resolver para el nodo inverso
    Resolver resolver = ens.resolver(reverseNodeHash);

    // Obtener el nombre preferido de la dirección
    return resolver.name(reverseNodeHash);
}
```

:::info
**Importante**: El cliente DEBE realizar una resolución hacia adelante en el registro inverso de un usuario para verificar que la dirección coincida con la que estás buscando. El ejemplo anterior no realiza esta verificación.
:::

Ten en cuenta que muchas librerías ya tienen funcionalidad para hacer esto. Puedes leer más sobre esto en la sección [Obteniendo un Nombre Primario](/web/reverse).
