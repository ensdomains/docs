import { NameProcessing } from '../../../components/NameProcessing'
import { Card } from '../../../components/ui/Card'

# Procesamiento de Nombres [Normalizaci√≥n y recomendaciones para c√≥mo manejar nombres]

Cuando interact√∫as directamente con los contratos inteligentes de ENS, es importante notar que los nombres no se almacenan como cadenas. Las [Librer√≠as](/es/web/libraries) manejan la codificaci√≥n de nombres por ti cuando implementan resoluci√≥n b√°sica de nombres, pero puedes necesitar manejar la codificaci√≥n t√∫ mismo cuando interact√∫as directamente con el protocolo.

Abajo hay una herramienta interactiva que muestra todos los diferentes formatos de nombres y c√≥mo implementarlos.

<Card>
  <NameProcessing />
</Card>

## Normalizaci√≥n de Nombres

La normalizaci√≥n es el proceso de canonizar un nombre antes de ejecutarlo a trav√©s del algoritmo [Namehash](#namehash). Es importante siempre normalizar toda la entrada, porque incluso una peque√±a diferencia (como un car√°cter en may√∫scula vs min√∫scula) causar√° que el namehash sea completamente diferente.

Por ejemplo, `NaMe.EtH` se normaliza a `name.eth`. Esto asegura que se use el nodo de Registro correcto, sin importar c√≥mo el usuario escriba el nombre.

Los nombres ENS se validan y normalizan usando el algoritmo de normalizaci√≥n [ENSIP-15](/ensip/15).

Anteriormente, se usaba [UTS-46](https://www.unicode.org/reports/tr46/), pero eso es insuficiente para secuencias de emojis. El procesamiento correcto de emojis solo es posible con [UTS-51](https://www.unicode.org/reports/tr51/). El algoritmo de normalizaci√≥n [ENSIP-15](/ensip/15) se basa en esos est√°ndares Unicode m√°s antiguos, pero tambi√©n agrega muchas otras reglas de validaci√≥n para prevenir t√©cnicas comunes de suplantaci√≥n como insertar caracteres de ancho cero, o usar caracteres confusos (parecidos). Ver aqu√≠ para discusi√≥n adicional sobre esto: [Homogylphs](https://support.ens.domains/en/articles/7901658-homoglyphs)

Una implementaci√≥n est√°ndar del algoritmo est√° disponible en [@adraffy/ens-normalize](https://github.com/adraffy/ens-normalize.js). Esta librer√≠a se usa bajo el cap√≥ en [viem](https://viem.sh/docs/ens/utilities/normalize), [ENSjs](https://github.com/ensdomains/ensjs/blob/main/packages/ensjs/src/utils/normalise.ts#L27), y otros.

```js
import { normalize } from 'viem/ens'

// Usa @adraffy/ens-normalize bajo el cap√≥

const normalized = normalize('RaFFYüö¥‚Äç‚ôÇÔ∏è.eTh')
// => "raffyüö¥‚Äç‚ôÇ.eth"
```

Si el nombre no pudo ser normalizado, entonces ese m√©todo lanzar√° un error. Un nombre es v√°lido si puede ser normalizado.

## Namehash

:::note
**DEBES** [normalizar](#normalize) un nombre antes de intentar crear un namehash! Si no lo haces, entonces el hash que obtengas puede ser incorrecto. Algunas librer√≠as como [ensjs](https://github.com/ensdomains/ensjs) har√°n esto autom√°ticamente por ti.
:::

En el registro central de ENS, los nombres se almacenan como un hash en lugar de la cadena cruda para optimizar gas, rendimiento, y m√°s. Este valor hasheado t√≠picamente se conoce como un `nodo`. El nodo es un valor de 32 bytes codificado en hex que se deriva del nombre usando el algoritmo `namehash` definido en [ENSIP-1](/ensip/1).

Namehash es un algoritmo recursivo que hashea cada parte del nombre, luego hashea los resultados juntos. Debido a que las funciones recursivas no son muy eficientes en Solidity, usualmente es mejor derivar el namehash fuera de la cadena y pasarlo a un contrato. Afortunadamente, hay librer√≠as que hacen esto por nosotros.

:::code-group

```tsx [Viem]
// https://viem.sh/docs/ens/utilities/namehash
import { namehash, normalize } from 'viem/ens'

const normalizedName = normalize('name.eth')
const node = namehash(normalizedName)
```

```ts [Ethers.js]
// https://docs.ethers.org/v6/api/hashing/#namehash
import { ensNormalize, namehash } from 'ethers/hash'

const normalizedName = ensNormalize('name.eth')
const node = namehash(normalizedName)
```

```python [ens-namehash-py]
# https://github.com/ConsenSysMesh/ens-namehash-py
from namehash import namehash

node = namehash('name.eth')
```

```rust [namehash-rust]
// https://github.com/InstateDev/namehash-rust
fn main() {
  let node = &namehash("name.eth");
  let s = hex::encode(&node);
}
```

```solidity [Solidity]
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@ensdomains/ens-contracts/contracts/utils/NameEncoder.sol";

contract MyContract {
    function namehash(string calldata name) public pure returns (bytes32) {
        (, bytes32 node) = NameEncoder.dnsEncodeName(name);
        return node;
    }
}
```

:::

### Algoritmo

La especificaci√≥n para el algoritmo namehash fue originalmente definida en [EIP-137](https://eips.ethereum.org/EIPS/eip-137#namehash-algorithm) (igual que [ENSIP-1](/ensip/1)).

Es un algoritmo recursivo que funciona hacia abajo hasta que llegas al dominio ra√≠z. Para `ens.eth`, el algoritmo funciona as√≠:

```
namehash('ens.eth') = keccak256(namehash('eth') + labelhash('ens'))
namehash('eth') = keccak256(namehash('') + labelhash('eth'))
namehash('') = 0x0000000000000000000000000000000000000000000000000000000000000000
```

Esa √∫ltima l√≠nea es un caso especial: El namehash para una cadena vac√≠a (representando el dominio ra√≠z) es 32 bytes nulos.

Si conectas todo arriba, terminar√°s con el valor namehash final:

```
namehash('') = 0x0000000000000000000000000000000000000000000000000000000000000000

labelhash('eth') = keccak256('eth') = 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0

namehash('eth') = keccak256(namehash('') + labelhash('eth')) = keccak256(0x00000000000000000000000000000000000000000000000000000000000000004f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0) = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae

labelhash('ens') = keccak256('ens') = 0x5cee339e13375638553bdf5a6e36ba80fb9f6a4f0783680884d92b558aa471da

namehash('ens.eth') = keccak256(namehash('eth') + labelhash('ens')) = keccak256(0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae5cee339e13375638553bdf5a6e36ba80fb9f6a4f0783680884d92b558aa471da) = 0x4e34d3a81dc3a20f71bbdf2160492ddaa17ee7e5523757d47153379c13cb46df

```

Esto nos lleva al nodo final para ens.eth: `0x4e34d3a81dc3a20f71bbdf2160492ddaa17ee7e5523757d47153379c13cb46df`

### Nodos Inversos

El [Nodo Inverso](/es/terminology#reverse-node) es un nodo en el Registro que puede ser reclamado para cualquier cuenta Ethereum. El nombre que este nodo representa es `[addr].addr.reverse`, donde `[addr]` es la direcci√≥n p√∫blica de Ethereum (min√∫scula, sin el "0x"). Estos nodos inversos t√≠picamente se usan para establecer un [Nombre Primario](#primary-name) para una cuenta.

Para generar el namehash para un nodo inverso:

- Toma la direcci√≥n de entrada y:
  - Remueve el "0x" al principio
  - Convierte todos los caracteres a min√∫scula
- Agrega `.addr.reverse` al final
- Ejecuta este resultado a trav√©s del algoritmo namehash

Por ejemplo, para la direcci√≥n `0x481f50a5BdcCC0bc4322C4dca04301433dED50f0`, el nombre para el nodo inverso es:

- `481f50a5bdccc0bc4322c4dca04301433ded50f0.addr.reverse`

Y el namehash resultante para el nodo inverso es:

- `0x58354ffdde6ac279f3a058aafbeeb14059bcb323a248fb338ee41f95fa544c86`

## Labelhash

:::note
**DEBES** [normalizar](#normalize) un nombre antes de intentar crear un labelhash! Si no lo haces, entonces el hash que obtengas puede ser incorrecto.
:::

Labelhash es el hash Keccak-256 de una sola etiqueta (ej. `name` en `name.eth`), usado en lugares que no requieren el nombre completo.

Un ejemplo de d√≥nde se usa labelhash es en el [BaseRegistar](/es/registry/eth), ya que solo soporta registrar 2LDs (dominios de segundo nivel, como `name.eth`) y no 3LDs+ (ej. `sub.name.eth`). El ID del token de un nombre .eth de segundo nivel en el BaseRegistar es el uint256 del labelhash.

:::code-group

```tsx [Viem]
// https://viem.sh/docs/ens/utilities/labelhash
import { labelhash, normalize } from 'viem/ens'

const normalizedLabel = normalize('label')
const hash = labelhash(normalizedLabel)
```

```tsx [Ethers]
// https://docs.ethers.org/v6/api/crypto/#keccak256
import { keccak256 } from 'ethers/crypto'
import { ensNormalize } from 'ethers/hash'
import { toUtf8Bytes } from 'ethers/utils'

const normalizedLabel = ensNormalize('label')
const labelhash = keccak256(toUtf8Bytes(normalizedLabel))
```

```solidity [Solidity]
string constant label = "label";
bytes32 constant labelhash = keccak256(bytes(label));
```

:::

## Codificaci√≥n DNS

:::note
**DEBES** [normalizar](#normalize) un nombre antes de codificarlo DNS! Si no lo haces, entonces cuando pases esos bytes codificados DNS a un m√©todo de contrato, se pueden derivar namehashes/labelhashes incorrectos.
:::

Este es un formato binario para nombres de dominio, que codifica la longitud de cada etiqueta junto con la etiqueta misma. Es usado por algunos de los contratos ENS, como cuando se envuelven nombres en el [Name Wrapper](/es/wrapper/overview) o se resuelven datos con [ENSIP-10](/ensip/10).

:::code-group

```tsx [Viem]
import { packetToBytes } from 'viem/ens'
import { toHex } from 'viem/utils'

const name = 'name.eth'
const dnsEncodedName = toHex(packetToBytes(name))
// 0x046e616d650365746800
```

```tsx [Ethers]
// https://docs.ethers.org/v6/api/hashing/#dnsEncode
import { dnsEncode } from 'ethers/lib/utils'

const dnsEncodedName = dnsEncode('name.eth')
```

```solidity [Solidity]
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@ensdomains/ens-contracts/contracts/utils/NameEncoder.sol";

contract MyContract {
    function dnsEncode(string calldata name) public pure returns (bytes memory) {
        (bytes memory dnsEncodedName,) = NameEncoder.dnsEncodeName(name);
        return dnsEncodedName;
    }
}
```

:::

### Decodificaci√≥n

Para decodificar un nombre codificado DNS, puedes usar `bytesToPacket()` de ENSjs.

```tsx
import { bytesToPacket } from '@ensdomains/ensjs/utils'
import { hexToBytes } from 'viem/utils'

const dnsEncodedName = '0x046e616d650365746800'
const name = bytesToPacket(hexToBytes(dnsEncodedName))
// name.eth
```

### Algoritmo

Para codificar DNS un nombre, primero divide el nombre en etiquetas (delimitadas por `.`). Luego para cada etiqueta de izquierda a derecha:

- Un byte para denotar la longitud de la etiqueta
- Los bytes codificados UTF-8 para la etiqueta
- Si esta es la √∫ltima etiqueta, entonces un byte NUL final (`0x00`).

Por ejemplo, para codificar DNS `my.name.eth`:

- `0x02` (longitud de la etiqueta "my")
- `0x6D79` (bytes codificados UTF-8 de "my")
- `0x04` (longitud de la etiqueta "name")
- `0x6E616D65` (bytes codificados UTF-8 de "name")
- `0x03` (longitud de la etiqueta "eth")
- `0x657468` (bytes codificados UTF-8 de "eth")
- `0x00` (marcador de fin de nombre)

Resultado final: `0x026d79046e616d650365746800`

:::note
Dado que la longitud de cada etiqueta se almacena en un solo byte, eso significa que con este esquema de codificaci√≥n DNS, cada etiqueta est√° limitada a ser 255 bytes codificados UTF-8 en longitud. Debido a esto, los nombres con etiquetas m√°s largas no pueden ser envueltos en el [Name Wrapper](/es/wrapper/overview), ya que ese contrato usa el nombre codificado DNS.
:::
