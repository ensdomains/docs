# Preparing for ENSv2 [Everything you need to know to prepare your application for ENSv2.]

ENSv2 brings multi-chain support and improved architecture to ENS. While names can still be stored on Ethereum Mainnet, ENSv2 introduces Namechain as the primary Layer 2 for ENS, with support for additional L2s as well. To ensure your application works seamlessly with ENSv2, you'll need to make a few key updates.

The good news? For most applications, preparing for ENSv2 is as simple as updating to the latest version of a [supported library](/web/libraries). At the time of writing, not all libraries have added ENSv2 support yet. Here's the current status:

- [viem >= v2.35.0](https://github.com/wevm/viem/blob/main/src/CHANGELOG.md#2350)
- ethers.js: Not published yet. [Work in progress on v6.16.0](https://github.com/ethers-io/ethers.js/tree/wip-v6.16.0-ens)
- web3.js: Deprecated

:::info
**Using a supported library? You're done!** Everything is handled automatically.

The sections below are optional reading for those who want to understand the technical details or test their integration manually.
:::

## Universal Resolver

Even though ENSv2 is designed for multi-chain, all resolution still starts on Ethereum Mainnet. There is a [new Universal Resolver](https://eth.blockscout.com/address/0xeEeEEEeE14D718C2B47D9923Deab1335E144EeEe) that acts as the canonical entry point. This is an upgradable proxy contract, so its address won't change in the future if its implementation is changed.

Your application needs to use this new Universal Resolver in order to be ready for ENSv2. As mentioned above, updating to the latest version of your supported web3 library handles this automatically.

Learn more about the [Universal Resolver here](/resolvers/universal) and about the [resolution process in general here](/resolution).

### Testing Universal Resolver Support

To test if your integration uses the Universal Resolver, try resolving the address for `ur.gtest.eth`. It should return `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE`. If it instead returns `0x1111111111111111111111111111111111111111`, you likely need to update your web3 library.

## CCIP Read

ENSv1 already supports delegating resolution from Ethereum Mainnet to an L2 or completely offchain using [CCIP Read (ERC-3668)](/learn/ccip-read). All the libraries mentioned above implement CCIP Read. However, not all integrations handle it properly.

With ENSv2, you can store names on Ethereum Mainnet, Namechain, or any other supported L2. This makes CCIP Read support essential for your integration to work correctly.

Learn more about [CCIP-Read, Offchain and L2 resolvers here](/resolvers/ccip-read).

### Testing CCIP Read Support

To test if your integration properly implements CCIP Read, try resolving `test.offchaindemo.eth`. It should return the address `0x779981590E7Ccc0CFAe8040Ce7151324747cDb97`.

## DNS Names and Name Detection

ENS supports importing DNS names into ENS, allowing legacy domain names to work alongside .eth names. It's important that your application correctly also detects DNS names.

### Common Mistake: Only Matching .eth

Many integrations check if the input ends with `.eth` in order to detect an ENS name:

```js
if (input.endsWith('.eth') {
  // ...
}
```

This is **incorrect** because it excludes DNS names imported into ENS (like `ensfairy.xyz`).

### Correct Pattern: Match All Valid Domains

Instead, your integration should treat any dot-separated string with as a potential ENS name. For example, `a.co` should be treated as a potential ENS name.

```js
if (input.includes('.') && input.length > 2) {
   // ...
}
```

This pattern correctly matches:

- `.eth` names like `vitalik.eth`
- DNS names like `ensfairy.xyz`
- Subdomains like `ses.fkey.id`
- Emoji domains like `ğŸ¦‡ï¸ğŸ”Šï¸ğŸ¦‡ï¸ğŸ”Šï¸ğŸ¦‡ï¸ğŸ”Šï¸.eth`

Learn more about [DNS integration here](/learn/dns). The full specification of name normalization is defined in [ENSIP-15](/ensip/15).

## Multichain Considerations

Even if your application only operates on an L2 like Base, ENS resolution always starts on Ethereum Mainnet. This means you need to configure Mainnet alongside your L2 chain.

### Configuring Both L2 and Mainnet

Here's how to set up your application to use Base (or another L2) while ensuring ENS resolution works correctly by including Mainnet:

:::code-group

```ts [Viem]
import { createPublicClient, http } from 'viem'
import { base, mainnet } from 'viem/chains'

// Client for Base transactions
const baseClient = createPublicClient({
  chain: base,
  transport: http(),
})

// Client for ENS resolution on Mainnet
const mainnetClient = createPublicClient({
  chain: mainnet,
  transport: http(),
})

// Get the Base address for this ENS name
const baseAddress = await mainnetClient.getEnsAddress({
  name: 'vitalik.eth',
  coinType: 8453, // Base chain ID
})
```

```tsx [Wagmi]
import { createConfig, http } from 'wagmi'
import { useEnsAddress } from 'wagmi'
import { base, mainnet } from 'wagmi/chains'

export const config = createConfig({
  chains: [base, mainnet], // Include both your L2 and Mainnet
  transports: {
    [base.id]: http(),
    [mainnet.id]: http(),
  },
})

// In your component - ENS resolution automatically uses Mainnet
function MyComponent() {
  // Get Base address
  const { data: baseAddress } = useEnsAddress({
    name: 'vitalik.eth',
    chainId: base.id,
  })
}
```

```ts [Ethers]
import { ethers } from 'ethers'

// Provider for Base
const baseProvider = new ethers.getDefaultProvider('base')

// Provider for ENS resolution on Mainnet
const mainnetProvider = new ethers.getDefaultProvider('mainnet')

// Get the Base address for this ENS name
const resolver = await mainnetProvider.getResolver('vitalik.eth')
const baseAddress = await resolver?.getAddress(8453) // Base chain ID
```

:::

